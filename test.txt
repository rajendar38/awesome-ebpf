1. Enabling HTTPS in Truststore-Service
Generate an SSL Certificate

You need an SSL certificate for HTTPS. You can use a self-signed certificate for local development.

Generate Self-Signed Certificate:

keytool -genkeypair -alias truststore-service -keyalg RSA -keysize 2048 -storetype PKCS12 \
  -keystore truststore-service.p12 -validity 365
-alias truststore-service: Alias for the certificate.
-keystore truststore-service.p12: The keystore file.
-validity 365: Valid for 365 days.
Update application.properties

Add the following properties to configure the server for HTTPS:

server.port=8443
server.ssl.key-store=classpath:truststore-service.p12
server.ssl.key-store-password=your-password
server.ssl.key-store-type=PKCS12
server.ssl.key-alias=truststore-service
server.ssl.key-store: Path to the keystore containing the SSL certificate.
server.ssl.key-store-password: Password for the keystore.
server.ssl.key-store-type: Keystore type (PKCS12 in this case).
server.ssl.key-alias: Alias of the key in the keystore.
Update Dockerfile

Ensure the keystore file is included in the Docker image:

# Copy the keystore to the image
COPY truststore-service.p12 /app/truststore-service.p12
2. Updating Api-Client-Service to Use HTTPS
Trust the SSL Certificate

The api-client-service needs to trust the certificate used by the truststore-service.

Export the Certificate from the Keystore:

keytool -export -alias truststore-service -file truststore-service.crt -keystore truststore-service.p12
Import the Certificate into a Truststore:

keytool -import -alias truststore-service -file truststore-service.crt -keystore client-truststore.jks -storepass changeit
Add Truststore to application.properties

In api-client-service, update application.properties:

truststore.api.url=https://truststore-service:8443/truststore
javax.net.ssl.trustStore=classpath:client-truststore.jks
javax.net.ssl.trustStorePassword=changeit
3. Update RestTemplate in Api-Client-Service
The default RestTemplate needs to be configured to use the truststore. Modify your configuration to include the trusted certificates.

import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.ssl.SSLContextBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

import javax.net.ssl.SSLContext;

@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate() throws Exception {
        SSLContext sslContext = SSLContextBuilder.create()
                .loadTrustMaterial(new TrustSelfSignedStrategy())
                .build();

        CloseableHttpClient httpClient = HttpClients.custom()
                .setSSLContext(sslContext)
                .setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE)
                .build();

        return new RestTemplate(new HttpComponentsClientHttpRequestFactory(httpClient));
    }
}
4. Update Docker Compose
Expose the HTTPS Port

Update the docker-compose.yml file for the truststore-service:

services:
  truststore-service:
    build:
      context: ./truststore-service
    ports:
      - "8443:8443"
Ensure the Keystore and Truststore Are Included

Add the keystore and truststore files to the appropriate services in their Dockerfiles:

# For truststore-service
COPY truststore-service.p12 /app/truststore-service.p12

# For api-client-service
COPY client-truststore.jks /app/client-truststore.jks
5. Testing HTTPS
Test Truststore-Service

Run the services with docker-compose and test the truststore-service with HTTPS:

curl -k https://localhost:8443/truststore
The -k flag allows ignoring certificate verification for testing.
Test Api-Client-Service

Call the /fetch-truststore endpoint on api-client-service:

curl http://localhost:8081/fetch-truststore



# Use an official Java runtime as a parent image
FROM openjdk:17-jdk-slim

# Set the working directory in the container
WORKDIR /app

# Copy the application JAR file into the container
COPY target/truststore-service.jar /app/truststore-service.jar

# Copy the SSL keystore file into the container
COPY truststore-service.p12 /app/truststore-service.p12

# Expose the HTTPS port
EXPOSE 8443

# Set environment variables for the SSL configuration
ENV SERVER_SSL_KEY_STORE=/app/truststore-service.p12
ENV SERVER_SSL_KEY_STORE_PASSWORD=your-password
ENV SERVER_SSL_KEY_STORE_TYPE=PKCS12

# Default command to run the JAR file
ENTRYPOINT ["java", "-Dserver.ssl.key-store=${SERVER_SSL_KEY_STORE}", \
                   "-Dserver.ssl.key-store-password=${SERVER_SSL_KEY_STORE_PASSWORD}", \
                   "-Dserver.ssl.key-store-type=${SERVER_SSL_KEY_STORE_TYPE}", \
                   "-jar", "/app/truststore-service.jar"]


# Use an official Java runtime as a parent image
FROM openjdk:17-jdk-slim

# Set the working directory in the container
WORKDIR /app

# Copy the application JAR file into the container
COPY target/api-client-service.jar /app/api-client-service.jar

# Copy the truststore file into the container (if custom truststore is used)
COPY truststore.jks /app/truststore.jks

# Expose the application port (if applicable, e.g., for debugging or other endpoints)
EXPOSE 8080

# Set environment variables for SSL truststore configuration
ENV JAVA_OPTS="-Djavax.net.ssl.trustStore=/app/truststore.jks \
               -Djavax.net.ssl.trustStorePassword=your-password"

# Default command to run the JAR file
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar /app/api-client-service.jar"]

